# Distributed Counter

이 예제는 기본적인 분산 카운터 앱을 만드는 과정을 담고 있습니다.

Sui Move 모듈을 작성하고 이를 React 기반의 Sui dApp과 연동하는 전체 과정을 다룹니다. 이 dApp은 누구나 카운터를 생성하고 값을 증가시킬 수 있지만, 카운터를 초기화(리셋)할 수 있는 권한은 소유자에게만 부여됩니다.

**가이드는 두 부분으로 나뉩니다.**

> 1.  스마트 컨트랙트: 카운터 구조체와 로직을 설정하는 Move 코드
> 2.  프론트엔드: 사용자가 카운터 객체를 생성하고, 증가시키며, 리셋할 수 있는 UI

이번 가이드는 `Shared Object`s에 대해서 다룹니다. Sui는 Object 중심의 Move 언어를 사용하며, 객체(Object)는 크게 `Shared Objects`와 `Owned Objects`로 나뉩니다. <br>

> Shared Objects는 여러 사용자가 동시에 접근할 수 있으며, 전역적으로 공유 가능한 객체
>
> Owned Objects는 특정 계정이 소유하며, 소유자만이 직접 접근하고 변경할 수 있는 객체

예를 들어 포커 게임을 생각해볼 수 있습니다.

> Shared Objects: 테이블 위의 포커 덱처럼, 모든 플레이어가 접근하고 카드를 뽑을 수 있는 객체
>
> Owned Objects: 각 플레이어가 들고 있는 손패처럼, 오직 해당 플레이어만 접근하고 볼 수 있는 객체

 <br>
이번 Distributed Counter에서는 Shared Objects를 사용하여 전역적으로 접근 가능한 카운터 객체(Counter objects)를 생성하고, 누구나 증가시킬 수 있도록 구현합니다.

## 1단계: 프로젝트 폴더 생성

새로운 폴더를 생성하여 이동합니다.

```bash
mkdir distributed-counter && cd distributed-counter
```

이 폴더는 프로젝트의 모든 파일을 담는 최상위 폴더입니다.
원하는 다른 이름으로 바꿔도 되지만, 이후 가이드에서는 이 구조를 기준으로 설명합니다.

## 2단계: Move 디렉토리 생성

```bash
mkdir -p ./move/counter/sources
```

`sources` 폴더에 move 코드가 작성될 것입니다.

## 3단계: Smart Contracts 작성

### 3-1: toml 파일 작성

스마트 컨트랙트를 작성하기 시작하려면, `distributed-counter/move/counter` 안에 `Move.toml` 파일을 생성하고, 다음 코드를 복사하여 붙여넣습니다.

```bash
[package]
name = "counter"
version = "0.0.1"
edition = "2024.beta"

[dependencies]
Sui = { git = "https://github.com/MystenLabs/sui.git", subdir = "crates/sui-framework/packages/sui-framework", rev = "framework/testnet" }

[addresses]
counter = "0x0"
```

`Move.toml`은 Move 패키지의 매니페스트 파일로, Move 모듈을 구성하고 관리하는 정보를 담고 있습니다.

### 1. [package]

패키지 자체의 기본 정보를 정의하는 필드입니다.

| 필드      | 설명                         | 예시 값       |
| --------- | ---------------------------- | ------------- |
| `name`    | 패키지 이름                  | `"counter"`   |
| `version` | 패키지 버전                  | `"0.0.1"`     |
| `edition` | Move 언어 버전/패키지 에디션 | `"2024.beta"` |

> 💡 **간단 설명**: 이 패키지가 어떤 이름과 버전으로 존재하는지, 어떤 Move 에디션을 사용하는지 알려주는 설정입니다.

### 2. [dependencies]

패키지가 의존하는 다른 Move 패키지나 라이브러리를 선언하는 필드입니다. 예제에서는 Sui 패키지를 Git 리포지토리에서 가져오도록 설정합니다.

| 필드     | 설명                             | 예시 값                                         |
| -------- | -------------------------------- | ----------------------------------------------- |
| `git`    | 패키지 Git URL                   | `"https://github.com/MystenLabs/sui.git"`       |
| `subdir` | 해당 리포지토리 내의 패키지 경로 | `"crates/sui-framework/packages/sui-framework"` |
| `rev`    | 사용할 브랜치나 커밋             | `"framework/testnet"`                           |

> 💡 **간단 설명**: 내 패키지가 다른 패키지(Sui 프레임워크)를 필요로 한다고 알려주는 설정입니다. `Distributed Counter`에서는 `transfer::share_object`를 사용하기 위해 Sui 프레임워크를 추가했습니다.

### 3. [addresses]

Move 패키지에서 사용할 전역 주소(Address) 매핑을 정의하는 필드입니다.

| 설정              | 설명                              |
| ----------------- | --------------------------------- |
| `counter = "0x0"` | counter 모듈이 배포될 주소를 지정 |

> 💡 **간단 설명**: Move 모듈에서 주소를 하드코딩하지 않고, 이름으로 참조할 수 있게 해줍니다.

### 3-2 `counter.move` 파일 생성 및 `module` 정의

distributed-counter/move/counter/sources 안에 `counter.move` 파일을 생성합니다.
파일 안에 아래 코드를 작성합니다.

```rust
module counter::counter;
```

`counter::counter는` 패키지 이름(counter)과 모듈 이름(counter)을 `::`로 구분한 네임스페이스입니다.

- 첫 번째 counter: 패키지 이름 (Move.toml의 `[package] name = "counter"`)

- 두 번째 counter: 모듈 이름, 이 안에 스마트 컨트랙트 로직을 작성

즉, “이 패키지 안에 counter라는 모듈을 만들겠다”라는 선언입니다.

> 패키지(Package) <br>
> 패키지 = Move 모듈들의 묶음 + 메타데이터
>
> Move.toml 파일로 정의하며, 하나의 패키지 안에는 여러 모듈을 포함할 수 있습니다.
>
> 패키지는 배포 단위입니다. 블록체인에 배포할 때 패키지 단위로 빌드 및 배포합니다.

> 모듈(Module) <br>
> 모듈 = 스마트 컨트랙트 또는 기능 단위 코드
>
> 패키지 안에서 정의하며, struct와 함수들을 포함합니다.
>
> 모듈 안에서 정의한 함수와 구조체는 다른 모듈이나 외부에서 불러서 사용할 수 있습니다.

### 3-3 `Counter` struct 생성

```rust
public struct Counter has key {
  id: UID,
  owner: address,
  value: u64
}
```

`Counter` 타입은 그 소유자의 주소(`owner`), 현재 상태(`value`), 그리고 자신의 아이디(`id`)을 저장합니다.

### Sui의 객체에서의`has key`와 `id`

> - `has key`: 이 구조체는 블록체인에서 고유하게 식별 가능한 객체임을 의미
>
> - `id`: `UID`: 객체마다 중복 없는 고유 ID를 가지고 있음 → 블록체인이 객체를 추적 가능

Move에서는 모든 자산과 데이터가 객체(Object) 단위로 소유권과 상태를 명확히 관리되도록 설계되어 있습니다. Sui에서 객체는 `has key`와 `UID` 덕분에 블록체인 상에서 누가 소유하고 있는지, 그리고 현재 값이 무엇인지 정확히 관리할 수 있습니다. 이는 소유자 권한 관리, 상태 추적, 동시성 처리, 데이터 일관성을 보장하는 데 필수적입니다.

### 3-4 `Counter`의 로직 작성

```rust
public fun create(ctx: &mut TxContext) {
  transfer::share_object(Counter {
    id: object::new(ctx),
    owner: ctx.sender(),
    value: 0
  })
}

public fun increment(counter: &mut Counter) {
  counter.value = counter.value + 1;
}

public fun set_value(counter: &mut Counter, value: u64, ctx: &TxContext) {
  assert!(counter.owner == ctx.sender(), 0);
  counter.value = value;
}
```

> `public`: 다른 모듈이나 사용자가 호출 가능
>
> `&mut`: 원본을 그대로 빌려서 읽고 쓸 수 있는 참조로, 함수 안에서 값을 직접 수정할 때 사용합니다. 즉, 객체를 생성하거나 상태를 바꿀 때 쓰면 됩니다.

### `Create`함수

```rust
public fun create(ctx: &mut TxContext)

```

**`ctx: &mut TxContext`: 트랜잭션 컨텍스트를 받아옵니다**

- Move/Sui에서는 트랜잭션이 누가 보냈는지, 어떤 자원이 사용되는지를 TxContext가 관리합니다.
- `&mut` → 함수 안에서 컨텍스트를 수정할 수 있습니다. (예: 새 객체 생성)

```rust
transfer::share_object(Counter { ... })
```

**`share_object` → Shared Object로 등록합니다.**

- Shared Object는 모든 사람이 접근 가능합니다.
- Distributed Counter에서는 여러 사용자가 increment 가능하게 만드는 핵심입니다.

```rust
Counter {
    id: object::new(ctx),
    owner: ctx.sender(),
    value: 0
  }
```

**`object::new(ctx)` → 새 UID를 생성합니다.**

- Sui에서 `has key` 객체를 만들 때 고유 ID를 만들어서 블록체인에 등록합니다.

**`ctx.sender()` → 이 트랜잭션을 실행한 보낸 사람의 주소**

- `Counter` 객체를 누가 소유하는지 `owner`로 지정합니다.

**`value: 0`**

- `Counter`의 초기 상태 값을 0으로 설정합니다.

### `increment` 함수

```rust
public fun increment(counter: &mut Counter)
```

**`counter: &mut Counter`: Counter 객체를 직접 수정할 수 있는 참조로 전달합니다.**

- Move에서는 값을 복사하지 않고 원본을 수정하므로, 함수에서 객체를 바꾸면 실제 블록체인 상의 상태가 바로 변경됩니다.

```rust
counter.value = counter.value + 1;
```

**`Counter` 객체 안의 현재 값을 `1` 증가시킵니다.**

### `set_value` 함수

```rust
public fun set_value(counter: &mut Counter, value: u64, ctx: &TxContext)
```

**`counter: &mut Counter`: Counter 객체의 원본을 직접 수정합니다.**

**`ctx: &TxContext`: 트랜잭션 정보를 전달합니다. (누가 호출했는지 확인 가능)**

```rust
assert!(counter.owner == ctx.sender(), 0);
```

**`counter.owner == ctx.sender()` → 이 Counter를 만든 사람과 호출자가 같은지 확인합니다.**

- `assert!` → 뒤의 조건이 참이 아니면 트랜잭션 실패합니다.
- `0` → 실패 시 반환할 에러 코드입니다.

> 즉, Counter의 값은 소유자만 바꿀 수 있습니다.

```rust
counter.value = value;
```

**전달받은 `value`로 Counter 값을 직접 변경합니다.**

### 3-5 전체 코드

최종 `module`은 다음과 같습니다.

```rust
module counter::counter;

public struct Counter has key {
    id: UID,
    owner: address,
    value: u64
}

public fun create(ctx: &mut TxContext) {
    transfer::share_object(Counter {
        id: object::new(ctx),
        owner: ctx.sender(),
        value: 0
    })
}

public fun increment(counter: &mut Counter) {
    counter.value = counter.value + 1;
}

public fun set_value(counter: &mut Counter, value: u64, ctx: &TxContext) {
    assert!(counter.owner == ctx.sender(), 0);
    counter.value = value;
}
```

## 4단계 Package 배포

### 4-1 Sui Client CLI 설치 확인

Package를 배포하기 전에, Sui Client CLI를 설정되어 있어야 합니다. 터미널을 열고 다음 명령을 실행하세요:

```bash
sui client
```

**만약 다음과 같은 응답을 받으면, 1.sui-cli-installation.md를 참고해서 Sui Client CLI를 설정하시기 바랍니다.**

```bash
Config file ["<FILE-PATH>/.sui/sui_config/client.yaml"] doesn't exist, do you want to connect to a Sui full node server [y/N]?
```

### 4-2 network `testnet`으로 설정

**예제에서는 `testnet`을 사용합니다.**

```bash
sui client switch --env testnet
```

### 4-3 가스비로 사용될 sui 토큰 받기

**배포를 하기 위해서는 가스비로 사용할 Testnet Sui 토큰이 필요합니다.**

**먼저 sui client에 사용되는 계정의 주소를 확인합니다.**

```bash
sui client active-address
```

위의 명령어를 통해 출력된 값이 현재 client 사용자의 주소입니다.

아래 Sui faucet 사이트에 방문하여 계정 주소를 입력하고 `Request Testnet SUI` 버튼을 누릅니다.

```plain text
https://faucet.sui.io/
```

아래 명령어를 입력하여 `balance`가 증가한 것을 확인합니다.

```bash
sui client balance
```

### 4-4 Package 배포

git을 사용할 경우 root 디렉토리에 `.gitignore` 파일을 생성후 아래와 같이 작성합니다.

```plain text
move/counter/build/
```

다음 명령어를 터미널에 입력하여 결과를 확인하세요. 이때 명령어는 `Move.toml`파일이 있는 같은 디렉토리(`move/counter`)에서 실행되어야 합니다.

```bash
sui client publish --gas-budget 20000000
```

> `Request rejected 429` 에러는 `Too Many Requests.` 에러로 발생시 배포 명령을 다시 실행해야 합니다. 배포가 계속 안될 경우 `RPC URL`을 바꿔줘야 합니다.
> 가스비가 너무 높을 경우 `--gas-budget 20000000`을 삭제해봅니다.

이 명령을 실행하면 아래와 같이 `packageID` 값이 출력되며, 이후에 package를 사용하기 위해 반드시 이 값을 저장해 두어야 합니다.

```bash
╭──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Object Changes                                                                                   │
├──────────────────────────────────────────────────────────────────────────────────────────────────┤
│ Created Objects:                                                                                 │
│  ┌──                                                                                             │
│  │ ObjectID: 0x5f460935265e2c7727a72db1dc2b9ac0b83b1554f6115ce0d411af1de6647aa6                  │
│  │ Sender: 0xd43008f2255d346b29a5a87b64a8f991373684a4cd73fe2ad57c31584bf68a0b                    │
│  │ Owner: Account Address ( 0xd43008f2255d346b29a5a87b64a8f991373684a4cd73fe2ad57c31584bf68a0b ) │
│  │ ObjectType: 0x2::package::UpgradeCap                                                          │
│  │ Version: 349167823                                                                            │
│  │ Digest: 8PC3Nay25qXP9icSK6sBLRxQZ7PGNYBZCMBY9Zj1WqLZ                                          │
│  └──                                                                                             │
│ Mutated Objects:                                                                                 │
│  ┌──                                                                                             │
│  │ ObjectID: 0xb57fb3a51ba2fc5d8eab8708779362eb49f54a6ceb7f0b4848e80c2062702afa                  │
│  │ Sender: 0xd43008f2255d346b29a5a87b64a8f991373684a4cd73fe2ad57c31584bf68a0b                    │
│  │ Owner: Account Address ( 0xd43008f2255d346b29a5a87b64a8f991373684a4cd73fe2ad57c31584bf68a0b ) │
│  │ ObjectType: 0x2::coin::Coin<0x2::sui::SUI>                                                    │
│  │ Version: 349167823                                                                            │
│  │ Digest: FGzs8gSsEGdhzsiNRb5Absf9u71coubptSGpsQUGgMh1                                          │
│  └──                                                                                             │
│ Published Objects:                                                                               │
│  ┌──                                                                                             │
│  │ PackageID: 0xad6ef04f3fcca07008be1bcc26a718c674d1ad494ef35ff3d2d20f4a9ecdab8e                 │
│  │ Version: 1                                                                                    │
│  │ Digest: 4r8tVf5a9StT28dxaQZty8u8Gxw4SP1DqVUvkQeg8Xto                                          │
│  │ Modules: counter                                                                              │
│  └──                                                                                             │
╰──────────────────────────────────────────────────────────────────────────────────────────────────╯
```

배포 후 터미널의 Object Changes에는 3개의 Object에 대한 트랜잭션 결과 요약이 나타납니다.

- `Created Objects` → 새로 만들어진 객체 (예: UpgradeCap)
- `Mutated Objects` → 기존 객체가 수정됨 (예: Sui 코인 수량 변경)
- `Published Objects` → Move 패키지 자체가 배포됨
  <br><br>

1. `Created Objects`
   - `UpgradeCap` 객체가 생성
   - `UpgradeCap`은 “이 패키지를 업그레이드할 수 있는 권한 증명서”
   - 즉, UpgradeCap을 가진 계정만 패키지를 재배포하거나 업그레이드가 가능합니다.
2. `Mutated Objects`
   - Mutated Objects는 이미 존재하는 객체가 변경된 경우 표시되며, 예시에서는 Sui 코인 객체가 업데이트되었습니다.
   - 즉, 예제에서는 Sui 코인 수량의 증가/감소, 거래 등의 결과가 표시되었습니다.
3. `Published Objects`
   - 배포된 `Counter Package`의 정보를 확인할 수 있습니다.
   - 프론트엔드와의 연결을 위해 Package의 고유 아이디인 `PackageID`를 따로 저장해둡니다.
     <br><br>

**`Object Changes`의 요소들**

- `ObjectID`: Sui 블록체인 상에서 이 객체의 고유 식별자.
- `Sender`: 이 객체를 생성한 계정 주소.
- `Owner`: 객체를 소유하는 계정(권한 있는 계정). 보통 Sender와 동일.
- `ObjectType`: 객체의 타입
- `Version`: 객체의 버전, 객체가 수정될 때마다 증가.
- `Digest`: 객체 내용의 해시값, 무결성 확인용.

## 5단계 프론트엔드 생성

### 5-1 프론트엔드 scaffold 생성

아래는 Sui Dapp을 생성하기 위한 기본 틀을 제공해주는 Scaffold를 생성하는 명령어입니다. `move` 폴더와 같은 루트 디렉토리에 생성해줍니다.

```bash
pnpm create @mysten/dapp --template react-client-dapp
```

Sui 공식 dApp 템플릿 패키지(@mysten/dapp)를 실행하고, 그 안에서 react-client-dapp 템플릿으로 새로운 dApp 프로젝트를 생성합니다. 이 탬플릿을 예제의 Scaffold로 사용할 것입니다. dApp의 이름을 `counter-dapp`으로 설정합니다.

### 5-2 필요한 dependencies 설치

git을 사용할 경우 `.gitignore` 파일에 다음을 추가합니다.

```plain text
node_modules/
```

이 앱은 아이콘 표시를 위해 `react-spinners` 패키지를 사용합니다. (`counter-dapp` 폴더로 이동 후 설치합니다.)

```bash
pnpm add react-spinners
```

### 5-3 `src/constants.ts` 파일 생성

`src` 폴더에 `constants.ts` 파일을 생성후 아래 코드를 작성합니다.

```typescript
export const DEVNET_COUNTER_PACKAGE_ID = "0xTODO";
export const TESTNET_COUNTER_PACKAGE_ID = <YOUR_PACKAGE_ADDRESS>;
export const MAINNET_COUNTER_PACKAGE_ID = "0xTODO";
```

`<YOUR_PACKAGE_ADDRESS>`에 4-4에 저장한 `packageID`를 입력합니다.

### 5-4 `src/networkConfig.ts` 파일 업데이트

`src/networkConfig.ts` 파일을 아래와 같이 업데이트합니다.

```typescript
import { getFullnodeUrl } from "@mysten/sui/client";
import {
  DEVNET_COUNTER_PACKAGE_ID,
  TESTNET_COUNTER_PACKAGE_ID,
  MAINNET_COUNTER_PACKAGE_ID,
} from "./constants.ts";
import { createNetworkConfig } from "@mysten/dapp-kit";

const { networkConfig, useNetworkVariable, useNetworkVariables } =
  createNetworkConfig({
    devnet: {
      url: getFullnodeUrl("devnet"),
      variables: {
        counterPackageId: DEVNET_COUNTER_PACKAGE_ID,
      },
    },
    testnet: {
      url: getFullnodeUrl("testnet"),
      variables: {
        counterPackageId: TESTNET_COUNTER_PACKAGE_ID,
      },
    },
    mainnet: {
      url: getFullnodeUrl("mainnet"),
      variables: {
        counterPackageId: MAINNET_COUNTER_PACKAGE_ID,
      },
    },
  });

export { useNetworkVariable, useNetworkVariables, networkConfig };
```

`variables`를 통해 `counter`의 `PackageId`를 사용할 수 있습니다.

### 5-5 `src/CreateCounter.tsx` 파일 생성

`src` 폴더에 `CreateCounter.tsx` 파일을 생성하고 아래와 같이 코드를 작성합니다.

```typescript
import { Transaction } from "@mysten/sui/transactions";
import { Button, Container } from "@radix-ui/themes";
import { useSignAndExecuteTransaction, useSuiClient } from "@mysten/dapp-kit";
import { useNetworkVariable } from "./networkConfig";
import ClipLoader from "react-spinners/ClipLoader";

export function CreateCounter({
  onCreated,
}: {
  onCreated: (id: string) => void;
}) {
  const counterPackageId = useNetworkVariable("counterPackageId");
  const suiClient = useSuiClient();
  const {
    mutate: signAndExecute,
    isSuccess,
    isPending,
  } = useSignAndExecuteTransaction();

  function create() {
    const tx = new Transaction();

    tx.moveCall({
      arguments: [],
      target: `${counterPackageId}::counter::create`,
    });

    signAndExecute(
      {
        transaction: tx,
      },
      {
        onSuccess: async ({ digest }) => {
          const { effects } = await suiClient.waitForTransaction({
            digest: digest,
            options: {
              showEffects: true,
            },
          });

          onCreated(effects?.created?.[0]?.reference?.objectId!);
        },
      }
    );
  }

  return (
    <Container>
      <Button
        size="3"
        onClick={() => {
          create();
        }}
        disabled={isSuccess || isPending}
      >
        {isSuccess || isPending ? <ClipLoader size={20} /> : "Create Counter"}
      </Button>
    </Container>
  );
}
```

### 1. 트랜잭션 생성

```typescript
const tx = new Transaction();

tx.moveCall({
  arguments: [],
  target: `${counterPackageId}::counter::create`,
});
```

- 새로운 트랜잭션 객체 tx 생성합니다.
- Move 모듈 호출(moveCall)합니다.
  - 호출 대상: counterPackageId 패키지 안의 counter 모듈의 create 함수
  - 인자: 없음 (arguments: [])

### 2. 트랜잭션 서명 및 실행

```typescript
signAndExecute({ transaction: tx }, { ... });
```

- 현재 연결된 지갑/클라이언트로 트랜잭션 서명 후 실행합니다.
- 콜백 제공 (onSuccess) → 트랜잭션이 성공하면 후속 처리합니다.

### 3. 트랜잭션 결과 확인 및 객체 ID 반환

```typescript
const { effects } = await suiClient.waitForTransaction({
  digest,
  options: { showEffects: true },
});

onCreated(effects?.created?.[0]?.reference?.objectId!);
```

- 트랜잭션이 블록체인에서 처리될 때까지 대기합니다.(`waitForTransaction`)
- 성공적으로 객체가 생성되면, 생성된 카운터 객체의 ObjectID를 추출하여 `onCreated` 콜백으로 전달합니다.

### 5-6 `src/Counter.tsx` 파일 생성

`src` 폴더에 `src/Counter.tsx` 파일을 생성하고 아래와 같이 코드를 작성합니다.

```typescript
import {
  useCurrentAccount,
  useSignAndExecuteTransaction,
  useSuiClient,
  useSuiClientQuery,
} from "@mysten/dapp-kit";
import type { SuiObjectData } from "@mysten/sui/client";
import { Transaction } from "@mysten/sui/transactions";
import { Button, Flex, Heading, Text } from "@radix-ui/themes";
import { useNetworkVariable } from "./networkConfig";
import { useState } from "react";
import ClipLoader from "react-spinners/ClipLoader";

export function Counter({ id }: { id: string }) {
  const counterPackageId = useNetworkVariable("counterPackageId");
  const suiClient = useSuiClient();
  const currentAccount = useCurrentAccount();
  const { mutate: signAndExecute } = useSignAndExecuteTransaction();
  const { data, isPending, error, refetch } = useSuiClientQuery("getObject", {
    id,
    options: {
      showContent: true,
      showOwner: true,
    },
  });

  const [waitingForTxn, setWaitingForTxn] = useState("");

  const executeMoveCall = (method: "increment" | "reset") => {
    setWaitingForTxn(method);

    const tx = new Transaction();

    if (method === "reset") {
      tx.moveCall({
        arguments: [tx.object(id), tx.pure.u64(0)],
        target: `${counterPackageId}::counter::set_value`,
      });
    } else {
      tx.moveCall({
        arguments: [tx.object(id)],
        target: `${counterPackageId}::counter::increment`,
      });
    }

    signAndExecute(
      {
        transaction: tx,
      },
      {
        onSuccess: (tx) => {
          suiClient.waitForTransaction({ digest: tx.digest }).then(async () => {
            await refetch();
            setWaitingForTxn("");
          });
        },
      }
    );
  };

  if (isPending) return <Text>Loading...</Text>;

  if (error) return <Text>Error: {error.message}</Text>;

  if (!data.data) return <Text>Not found</Text>;

  const ownedByCurrentAccount =
    getCounterFields(data.data)?.owner === currentAccount?.address;

  return (
    <>
      <Heading size="3">Counter {id}</Heading>

      <Flex direction="column" gap="2">
        <Text>Count: {getCounterFields(data.data)?.value}</Text>
        <Flex direction="row" gap="2">
          <Button
            onClick={() => executeMoveCall("increment")}
            disabled={waitingForTxn !== ""}
          >
            {waitingForTxn === "increment" ? (
              <ClipLoader size={20} />
            ) : (
              "Increment"
            )}
          </Button>
          {ownedByCurrentAccount ? (
            <Button
              onClick={() => executeMoveCall("reset")}
              disabled={waitingForTxn !== ""}
            >
              {waitingForTxn === "reset" ? <ClipLoader size={20} /> : "Reset"}
            </Button>
          ) : null}
        </Flex>
      </Flex>
    </>
  );
}
function getCounterFields(data: SuiObjectData) {
  if (data.content?.dataType !== "moveObject") {
    return null;
  }

  return data.content.fields as { value: number; owner: string };
}
```

### 1. `useSuiClientQuery("getObject", { id })`로 object의 데이터 받아오기

- Object ID를 이용해 query를 수행하고, 해당 Object의 내용(`content`)과 소유자(`owner`) 등의 정보를 받아옵니다.

### 2. `getCounterFields`로 필요한 필드 추출

- `SuiObjectData`를 파라미터 값으로 받으며, `useSuiClientQuery`로 가져온 `data.data`값을 넘겨받습니다.
- `fields`에서 카운터 값(`value`)과 소유자(`owner`)만 추출합니다.

### 3. `executeMoveCall`로 트랜잭션 생성, 서명과 실행

- `CreateCounter` 파일과 마찬가지로 트랜잭션을 생성하고, `signAndExecute`로 트랜잭션 서명 후 실행합니다.

### 5-7 routing을 업데이트합니다.

`src` 폴더의 `App.tsx` 파일을 다음과 같이 업데이트합니다.

```typescript
import { ConnectButton, useCurrentAccount } from "@mysten/dapp-kit";
import { isValidSuiObjectId } from "@mysten/sui/utils";
import { Box, Container, Flex, Heading } from "@radix-ui/themes";
import { useState } from "react";
import { Counter } from "./Counter";
import { CreateCounter } from "./CreateCounter";

function App() {
  const currentAccount = useCurrentAccount();
  const [counterId, setCounter] = useState(() => {
    const hash = window.location.hash.slice(1);
    return isValidSuiObjectId(hash) ? hash : null;
  });

  return (
    <>
      <Flex
        position="sticky"
        px="4"
        py="2"
        justify="between"
        style={{
          borderBottom: "1px solid var(--gray-a2)",
        }}
      >
        <Box>
          <Heading>dApp Starter Template</Heading>
        </Box>

        <Box>
          <ConnectButton />
        </Box>
      </Flex>
      <Container>
        <Container
          mt="5"
          pt="2"
          px="4"
          style={{ background: "var(--gray-a2)", minHeight: 500 }}
        >
          {currentAccount ? (
            counterId ? (
              <Counter id={counterId} />
            ) : (
              <CreateCounter
                onCreated={(id) => {
                  window.location.hash = id;
                  setCounter(id);
                }}
              />
            )
          ) : (
            <Heading>Please connect your wallet</Heading>
          )}
        </Container>
      </Container>
    </>
  );
}

export default App;
```

`OwnedObjects.tsx`와 `WalletStatus.tsx` 파일은 삭제해도 됩니다.

## 6단계 프론트엔드 실행

`distributed-counter/counter-dapp` 디렉토리에서 다음 명령어를 실행합니다.

```bash
pnpm run dev
```

아래 url로 접속합니다.

```plaintext
http://localhost:5173/
```

## 7단계 Dapp과 상호작용

url을 접속하면 아래와 같은 화면으로 이동할 것입니다.
![frontend main](/images/4.Distributed-Counter/Frontend_main.png)

### 7-1 지갑 연결

Dapp과 상호작용하기 위해서는 지갑을 먼저 연결해야 합니다.
만약 Sui의 `Slush` 지갑이 없다면 먼저 설치해 주세요.

화면의 오른쪽 상단의 `Connect Wallet` 버튼을 누르고 `Slush` 지갑을 선택합니다.

`Connection request`를 `Approve`해줍니다.

![after connecting wallet](/images/4.Distributed-Counter/after_connecting_wallet.png)

지갑을 연결하면 위와 같이 `Create Counter` 버튼을 확인할 수 있습니다.

### 7-2 Slush 지갑에 가스비 충전

하지만 지금은 `Create Counter` 버튼을 눌러 로직을 실행할 수 없습니다. 가스비가 없기 때문입니다.

이제 Sui Client의 계정에 있는 Sui 토큰을 Slush 지갑의 계정으로 옮길겁니다.

먼저 Sui Client의 `active-address`를 확인합니다. (새로운 터미널을 열어서 실행합니다.)

```bash
sui client active-address
```

이제 다음 명령어를 통해 Sui 토큰 Object를 확인합니다.

```bash
sui client gas <YOUR_ADDRESS>
```

아래와 같이 `gasCoinId`(sui object id)를 확인 할 수 있습니다.

![gas coin id](/images/4.Distributed-Counter/gas_coin_id.png)

이 중 하나의 `gasCoinId`를 선택해서 옮길겁니다.

다음 명령어를 통해 Sui 토큰을 옮깁니다. (`amounts`의 단위는 `MIST`입니다. `gasCoinId`의 `mistBalance`를 확인해주세요.)

```bash
sui client pay-sui --recipients <YOUR_SLUSH_WALLET_ADDRESS> --input-coins <GAS_COIN_ID> --amounts <AMOUNT_IN_MIST> --gas-budget 5000000
```

> `Request rejected 429` 에러가 발생하면 다시 시도하거나, 배포가 계속 안될 경우 `RPC URL`을 바꿔줘야 합니다.

### 7-3 Create Counter

이제 `Create Counter` 버튼을 눌러봅니다.

`Slush` 지갑을 통해 서명을 완료합니다.

![create counter object](/images/4.Distributed-Counter/create_counter_object.png)

서명을 하면 위와 같이 `Counter Object`의 데이터와 `Increment`와 `Reset` 버튼을 확인할 수 있습니다.

### 7-4 Increment & Reset

`increment` 버튼을 누르고 서명을 하면 아래와 같이 `Count`가 `1`만큼 증가한 것을 확인할 수 있습니다.

[ Increment ]
![Increment](/images/4.Distributed-Counter/Increment.png)

`Reset` 버튼을 누르고 서명을 하면 `Count`가 다시 `0`으로 초기화됩니다.

[ Reset ]
![Increment](/images/4.Distributed-Counter/Reset.png)

### 7-4 Slush 지갑을 바꿔 연결

`Slush` 지갑의 계정을 하나 더 생성해봅니다.

![Add Account](/images/4.Distributed-Counter/add_account.png)

`Manage Accounts`에서 `Add account` 버튼을 눌러서 계정을 새로 만들 수 있습니다.

Dapp 페이지에서 `Disconnect` 버튼을 눌러 지갑과의 연결을 끊고 `Connect Wallet`으로 새로운 지갑 계정을 연결합니다.

[Disconnect]
![Disconnect](/images/4.Distributed-Counter/Disconnect.png)

새로운 계정을 연결하면 아래와 같은 화면이 나타날 것입니다.

![reconnect](/images/4.Distributed-Counter/reconnect.png)

우리가 만든 `Counter` 객체는 `Shared Object`이기 때문에, 바뀐 계정으로 접근해 `increment` 함수를 실행할 수 있습니다. 하지만 `reset(set_value)` 함수는 `owner`만 호출할 수 있으므로, 계정을 변경한 뒤에는 실행할 수 없습니다.
