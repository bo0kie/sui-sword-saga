# Tic-Tac-Toe

이번 가이드는 Move로 3X3 보드의 tic-tac-toe를 만드는 과정을 소개합니다. 이 예제는 4. Distributed-Counter 과정을 먼저 수행한 분들을 대상으로 합니다. 앞선 내용과 중복되는 부분은 생략했으니, 처음 진행하시는 분들은 먼저 해당 예제를 학습하시기를 권장합니다.

## 1단계: 프로젝트 폴더 생성

새로운 폴더를 생성하여 이동합니다.

```bash
mkdir tic-tac-toe && cd tic-tac-toe
```

이 폴더는 프로젝트의 모든 파일을 담는 최상위 폴더입니다.
원하는 다른 이름으로 바꿔도 되지만, 이후 가이드에서는 이 구조를 기준으로 설명합니다.

## 2단계: Move 디렉토리 생성

```bash
mkdir -p ./move/sources
```

`sources` 폴더에 move 코드가 작성될 것입니다.

## 3단계: Smart Contracts 작성

### 3-1: toml 파일 작성

스마트 컨트랙트를 작성하기 시작하려면, `tic-tac-toe/move` 안에 `Move.toml` 파일을 생성하고, 다음 코드를 복사하여 붙여넣습니다. `sources` 폴더와 `Move.toml`은 같은 폴더에 있어야 합니다.

```bash
[package]
name = "tic_tac_toe"
edition = "2024.beta"

[dependencies]
[addresses]
tic_tac_toe = "0x0"
```

`Move.toml`은 Move 패키지의 매니페스트 파일로, Move 모듈을 구성하고 관리하는 정보를 담고 있습니다. 각 요소의 자세한 정보는 `4. Distributed-Counter.md`의 `3-1`을 확인하세요.

### 3-2 `owned.move` 파일 생성 및 `module` 정의

tic-tac-toe/move/sources 안에 `owned.move` 파일을 생성합니다.
파일 안에 아래 코드를 작성합니다.

```rust
module tic_tac_toe::owned;
```

### 3-3 `use` 작성

use는 다른 모듈에서 정의된 기능(함수, struct, constant 등)을 현재 모듈 안으로 가져오는 키워드입니다.

```rust
use sui::event;
use sui::transfer::Receiving;
```

### `sui::event`

- 이벤트를 발생시킬 때 사용하는 기능들을 제공합니다.
- 스마트 컨트랙트 실행 중 중요한 상태 변화를 기록하거나, 프론트엔드/오프체인 서비스에서 모니터링할 수 있도록 신호를 남길 때 사용합니다.

### `sui::transfer::Receiving`

- 해당 트랜잭션에서 수신될 수 있는 Move 객체입니다.

### 3-4 object type 정의

```rust
// === Object Types ===

/// The state of an active game of tic-tac-toe.
public struct Game has key, store {
    id: UID,
    /// Marks on the board.
    board: vector<u8>,
    /// The next turn to be played.
    turn: u8,
    /// The address expected to send moves on behalf of X.
    x: address,
    /// The address expected to send moves on behalf of O.
    o: address,
    /// Public key of the admin address.
    admin: vector<u8>,
}

/// The player that the next turn is expected from is given a `TurnCap`.
public struct TurnCap has key {
    id: UID,
    game: ID,
}

/// A request to make a play -- only the player with the `TurnCap` can
/// create and send `Mark`s.
public struct Mark has key, store {
    id: UID,
    player: address,
    row: u8,
    col: u8,
}

/// An NFT representing a finished game. Sent to the winning player if there
/// is one, or to both players in the case of a draw.
public struct Trophy has key {
    id: UID,
    /// Whether the game was won or drawn.
    status: u8,
    /// The state of the board at the end of the game.
    board: vector<u8>,
    /// The number of turns played
    turn: u8,
    /// The other player (relative to the player who owns this Trophy).
    other: address,
}
```

### `vector<u8>`

- vector\<T>는 Move에서 제공하는 가변 길이 배열(list) 타입입니다.
- 여기서 T는 원소의 타입을 뜻하고, u8은 8비트 부호 없는 정수(0~255)를 의미합니다.
- 따라서 vector\<u8>은 바이트 배열(byte array)을 표현한다고 보면 됩니다.

### `game: ID`

- ID는 Move에서 객체(Object)의 고유 식별자를 나타내는 타입입니다.
- 어떤 Game 객체에 연결된 턴 권한인지를 가리키는 역할입니다.

### 3-5 event types와 constants

```rust
// === Event Types ===

public struct MarkSent has copy, drop {
    game: ID,
    mark: ID,
}

public struct GameEnd has copy, drop {
    game: ID,
}

// === Constants ===

// Marks
const MARK__: u8 = 0;
const MARK_X: u8 = 1;
const MARK_O: u8 = 2;

// Trophy status
const TROPHY_NONE: u8 = 0;
const TROPHY_DRAW: u8 = 1;
const TROPHY_WIN: u8 = 2;
```

### event type

- Sui Move에서는 `event::emit<T>(event)`을 통해 체인에 기록되는 로그를 남길 수 있습니다.
- 이때 T는 보통 struct로 정의된 이벤트 타입입니다.
- 이 타입은 체인에서 직접 소유되거나 조작할 수는 없습니다.

### 3-6 에러 정의

```rust
// === Errors ===

#[error]
const EInvalidLocation: vector<u8> = b"Move was for a position that doesn't exist on the board";

#[error]
const EWrongPlayer: vector<u8> = b"Game expected a move from another player";

#[error]
const ENotFinished: vector<u8> = b"Game has not reached an end condition";

#[error]
const EAlreadyFinished: vector<u8> = b"Can't place a mark on a finished game";

#[error]
const EInvalidEndState: vector<u8> = b"Game reached an end state that wasn't expected";
```

### [error]

- Move 에러 코드(error constant)로 지정합니다.
- `b"..."` 구문은 문자열을 바이트 배열로 변환합니다.

### 3-7 private helper 함수 정의

```rust
// === Private Helpers ===

/// Address of the player the move is expected from, the address of the
/// other player, and the mark to use for the upcoming move.
fun next_player(game: &Game): (address, address, u8) {
    if (game.turn % 2 == 0) {
        (game.x, game.o, MARK_X)
    } else {
        (game.o, game.x, MARK_O)
    }
}

/// Test whether the values at the triple of positions all match each other
/// (and are not all EMPTY).
fun test_triple(game: &Game, x: u8, y: u8, z: u8): bool {
    let x = game.board[x as u64];
    let y = game.board[y as u64];
    let z = game.board[z as u64];

    MARK__ != x && x == y && y == z
}

/// Create a trophy from the current state of the `game`, that indicates
/// that a player won or drew against `other` player.
fun mint_trophy(game: &Game, status: u8, other: address, ctx: &mut TxContext): Trophy {
    Trophy {
        id: object::new(ctx),
        status,
        board: game.board,
        turn: game.turn,
        other,
    }
}

fun mark(game: &Game, row: u8, col: u8): &u8 {
    &game.board[(row * 3 + col) as u64]
}

fun mark_mut(game: &mut Game, row: u8, col: u8): &mut u8 {
    &mut game.board[(row * 3 + col) as u64]
}
```

### `next_player`

- Game object를 입력받아 `turn`의 홀/짝 여부로 다음 턴이 누구 차례인지 판단하고, 해당 턴에 둘 마크를 판단해 알려줍니다.

### `test_triple`

- Game object와 세 개의 위치 인덱스를 받아서, 그 세 칸에 있는 값이 모두 같은지 확인합니다.
- 단, 모두 빈 칸(`MARK__`)이면 안 되도록 조건을 넣습니다.

### `mint_trophy`

- 새로운 Trophy object를 `mint`합니다.

### `mark`와 `mut_mark`

- `mark` → 게임판(board)에서 주어진 (`row`, `col`) 위치의 값을 읽기 전용으로 가져옵니다.
- `mark_mut` → 같은 위치의 값을 수정 가능하게 가져옵니다.
- 두 함수 모두 1차원 배열(`vector<u8>`)을 2차원 좌표처럼 다룰 수 있게 해주는 도우미 역할을 합니다.
  즉, (row \* 3 + col) 계산을 통해 (행, 열) 좌표를 1차원 인덱스로 바꿉니다: (0,0) → 0, (1,0) → 3, (2,2) → 8.

### 3-8 public 함수 정의

```rust
// === Public Functions ===

/// Create a new game, played by `x` and `o`. The game should be
/// transfered to the address that will administrate the game. If
/// that address is a multi-sig of the two players, its public key
/// should be passed as `admin`.
public fun new(x: address, o: address, admin: vector<u8>, ctx: &mut TxContext): Game {
    let game = Game {
        id: object::new(ctx),
        board: vector[MARK__, MARK__, MARK__, MARK__, MARK__, MARK__, MARK__, MARK__, MARK__],
        turn: 0,
        x,
        o,
        admin,
    };

    let turn = TurnCap {
        id: object::new(ctx),
        game: object::id(&game),
    };

    // X is the first player, so send the capability to them.
    transfer::transfer(turn, x);
    game
}

/// Called by the active player to express their intention to make a move.
/// This consumes the `TurnCap` to prevent a player from making more than
/// one move on their turn.
public fun send_mark(cap: TurnCap, row: u8, col: u8, ctx: &mut TxContext) {
    assert!(row < 3 && col < 3, EInvalidLocation);

    let TurnCap { id, game } = cap;
    id.delete();

    let mark = Mark {
        id: object::new(ctx),
        player: ctx.sender(),
        row,
        col,
    };

    event::emit(MarkSent { game, mark: object::id(&mark) });
    transfer::transfer(mark, game.to_address());
}

/// Called by the admin (who owns the `Game`), to commit a player's
/// intention to make a move. If the game should end, `Trophy`s are sent to
/// the appropriate players, if the game should continue, a new `TurnCap` is
/// sent to the player who should make the next move.
public fun place_mark(game: &mut Game, mark: Receiving<Mark>, ctx: &mut TxContext) {
    assert!(ended(game) == TROPHY_NONE, EAlreadyFinished);

    // Fetch the mark on behalf of the game -- only works if the mark in
    // question was sent to this game.
    let Mark { id, row, col, player } = transfer::receive(&mut game.id, mark);
    id.delete();

    // Confirm that the mark is from the player we expect -- it should not
    // be possible to hit this assertion, because the `Mark`s can only be
    // created by the address that owns the `TurnCap` which cannot be
    // transferred, and is always held by `game.next_player()`.
    let (me, them, sentinel) = game.next_player();
    assert!(me == player, EWrongPlayer);

    if (*mark(game, row, col)== MARK__) {
        *mark_mut(game, row, col) = sentinel;
        game.turn = game.turn + 1;
    };

    // Check win condition -- if there is a winner, send them the trophy,
    // otherwise, create a new turn cap and send that to the next player.
    let end = ended(game);
    if (end == TROPHY_WIN) {
        transfer::transfer(game.mint_trophy(end, them, ctx), me);
        event::emit(GameEnd { game: object::id(game) });
    } else if (end == TROPHY_DRAW) {
        transfer::transfer(game.mint_trophy(end, them, ctx), me);
        transfer::transfer(game.mint_trophy(end, me, ctx), them);
        event::emit(GameEnd { game: object::id(game) });
    } else if (end == TROPHY_NONE) {
        let cap = TurnCap { id: object::new(ctx), game: object::id(game) };
        let (to, _, _) = game.next_player();
        transfer::transfer(cap, to);
    } else {
        abort EInvalidEndState
    }
}

public fun burn(game: Game) {
    assert!(ended(&game) != TROPHY_NONE, ENotFinished);
    let Game { id, .. } = game;
    id.delete();
}

/// Test whether the game has reached an end condition or not.
public fun ended(game: &Game): u8 {
    if (// Test rows
        test_triple(game, 0, 1, 2) ||
            test_triple(game, 3, 4, 5) ||
            test_triple(game, 6, 7, 8) ||
            // Test columns
            test_triple(game, 0, 3, 6) ||
            test_triple(game, 1, 4, 7) ||
            test_triple(game, 2, 5, 8) ||
            // Test diagonals
            test_triple(game, 0, 4, 8) ||
            test_triple(game, 2, 4, 6)) {
        TROPHY_WIN
    } else if (game.turn == 9) {
        TROPHY_DRAW
    } else {
        TROPHY_NONE
    }
}
```

### `new` 함수

### Game object 생성

```rust
let game = Game {
    id: object::new(ctx),
    board: vector[MARK__, MARK__, MARK__, MARK__, MARK__, MARK__, MARK__, MARK__, MARK__],
    turn: 0,
    x,
    o,
    admin,
};
```

- `board`: 3×3 틱택토 보드, 처음에는 모두 빈 칸(`MARK__`)입니다.
- `turn`: 0으로 초기화 → 첫 턴은 x 플레이어가 둡니다. (다음부터 턴은 `next_player` 함수에 의해서 결정됩니다.)
- `x`, `o`: 두 플레이어의 주소입니다.
- `admin`: 관리자의 공개키입니다. (이번 예제에서는 사용되지 않습니다.)

### `TurnCap` 생성

```rust
let turn = TurnCap {
    id: object::new(ctx),
    game: object::id(&game),
};
```

- `TurnCap`은 “누가 지금 차례를 둘 수 있는지”를 나타내는 객체입니다.
- `game`: 방금 만든 Game 객체의 ID와 연결됩니다.

### TurnCap X 플레이어에게 전달, Game object 리턴

```rust
transfer::transfer(turn, x);

game
```

- 생성한 `TurnCap을` `X` 플레이어 주소로 전송합니다.
- 이제 플레이어 x만이 `place_mark` 함수를 호출해 수를 둘 수 있게 됩니다.

### `send_mark` 함수

### 유효성 검증

```rust
assert!(row < 3 && col < 3, EInvalidLocation);
```

- `row`, `col`이 0,1,2 범위 안에 있는지 체크합니다.

### `TurnCap` 소모

```rust
let TurnCap { id, game } = cap;
id.delete();
```

- TurnCap 구조체를 분해해서 `game ID`만 남깁니다.
- `id.delete()`로 TurnCap 객체를 제거하여 한 턴에 두 번 두지 못하도록 강제합니다.

### 새 Mark 객체 생성

```rust
let mark = Mark {
    id: object::new(ctx),
    player: ctx.sender(),
    row,
    col,
};
```

- `player`: 트랜잭션을 보낸 주소(= 지금 Mark를 두는 사람)입니다.
- `row`, `col`: 두려는 위치

### `MarkSent` event 발생

```rust
event::emit(MarkSent { game, mark: object::id(&mark) });
```

- Move 표준 라이브러리의 event 모듈 함수로, 전달된 이벤트를 체인에 기록(`log`)합니다.
- 이 이벤트는 상태로 저장되는 건 아니고, 트랜잭션 실행 로그로 남습니다.
- `MarkSent` 구조체 타입의 이벤트 값을 하나 생성합니다.
  - `game`: 이 턴이 속한 게임의 ID
  - `mark`: 방금 만든 Mark 객체의 ID입니다. (즉, 어떤 마크인지 식별)

### Mark를 Game object로 전송

```rust
transfer::transfer(mark, game.to_address());
```

- 생성된 Mark를 Game 객체가 관리하는 주소로 전송합니다.
- 이후 `place_mark` 함수에서 이 Mark를 받아서 실제 보드에 반영합니다
- `to_address()`는 어떤 객체의 `ID`를 주소(`address`)로 변환하는 함수입니다.

### `place_mark` 함수

### 게임 진행중인지 확인

```rust
assert!(ended(game) == TROPHY_NONE, EAlreadyFinished);
```

- `TROPHY_NONE`은 게임 진행중임을 의미합니다.

### 보낸 Mark 수신

```rust
let Mark { id, row, col, player } = transfer::receive(&mut game.id, mark);
id.delete();
```

- `transfer::receive` 함수는 특정 객체(예: Mark)를 다른 객체(예: Game)의 "Dynamic Field"로 안전하게 받아오는 역할을 합니다. 내부적으로는 `game.id`가 진짜로 해당 Mark 객체를 받을 권한이 있는지 체크합니다.
- `Mark { id, row, col, player }`로 분해 후 `id.delete()`로 객체를 삭제합니다. (Mark 이중 사용 금지)

Dynamic Field는 객체(Object) 안에 "동적으로" 여러 개의 하위 객체(필드)를 저장할 수 있게 해주는 기능입니다.

### 보드 반영과 턴 증가

```rust
if (*mark(game, row, col)== MARK__) {
        *mark_mut(game, row, col) = sentinel;
        game.turn = game.turn + 1;
    };
```

`*mark(game, row, col) == MARK__`

1. `mark(game, row, col)`는 (row, col) 좌표의 보드 칸을 가리키는 불변 참조(`&u8`)를 반환합니다.
2. `*mark(...)` → 참조 해제(dereference)해서 실제 값(`u8`)을 가져옵니다.
3. `== MARK__`→ 그 값이 `MARK__`(빈 칸을 나타내는 상수)인지 비교합니다.

`*mark_mut(game, row, col) = sentinel;`

1. `mark_mut(game, row, col)` → (row, col) 좌표의 보드 칸을 가리키는 가변 참조(`&mut u8`)를 반환합니다.
2. `*mark_mut(...)` → 참조 해제해서 실제 칸 값에 접근합니다.
3. `= sentinel` → 그 위치에 sentinel 값을 대입합니다. (예: `MARK_X` 또는 `MARK_O`)

### 불변 참조 vs 가변 참조 (러스트 문법)

1. 불변 참조 (`&T`)

- 값을 읽기만 할 수 있는 참조
- 여러 개 동시에 존재해도 괜찮음
- 예: `mark(&game, 0, 0)` → 칸의 값을 확인만 가능

2. 가변 참조 (`&mut T`)

- 값을 읽고, 수정도 할 수 있는 참조
- 동시에 단 하나만 존재해야 함 (데이터 충돌 방지)
- 예: `mark_mut(&mut game, 0, 0)` → 칸의 값을 바꿀 수 있음

### 종료 판정 후 처리

```rust
    let end = ended(game);
    if (end == TROPHY_WIN) {
        transfer::transfer(game.mint_trophy(end, them, ctx), me);
        event::emit(GameEnd { game: object::id(game) });
    } else if (end == TROPHY_DRAW) {
        transfer::transfer(game.mint_trophy(end, them, ctx), me);
        transfer::transfer(game.mint_trophy(end, me, ctx), them);
        event::emit(GameEnd { game: object::id(game) });
    } else if (end == TROPHY_NONE) {
        let cap = TurnCap { id: object::new(ctx), game: object::id(game) };
        let (to, _, _) = game.next_player();
        transfer::transfer(cap, to);
    } else {
        abort EInvalidEndState
    }
```

- `ended()`으로 경기 종료 여부를 판단합니다.
- 승리(`TROPHY_WIN`): 승자에게 트로피 전송, GameEnd 이벤트 기록합ㄴ디ㅏ.
- 무승부(`TROPHY_DRAW`): 양쪽 모두에게 트로피 전송, GameEnd 이벤트 기록합니다.
- 진행(`TROPHY_NONE`): 새 TurnCap 만들어 다음 플레이어에게 전송합니다.

### `burn` 함수

- 게임이 끝났을 때 Game 객체를 체인에서 제거하는 역할을 합니다.

### `ended` 함수

### 승리 판정

```rust
/// Test whether the game has reached an end condition or not.
public fun ended(game: &Game): u8 {
    if (// Test rows
        test_triple(game, 0, 1, 2) ||
            test_triple(game, 3, 4, 5) ||
            test_triple(game, 6, 7, 8) ||
            // Test columns
            test_triple(game, 0, 3, 6) ||
            test_triple(game, 1, 4, 7) ||
            test_triple(game, 2, 5, 8) ||
            // Test diagonals
            test_triple(game, 0, 4, 8) ||
            test_triple(game, 2, 4, 6)) {
        TROPHY_WIN
    } else if (game.turn == 9) {
        TROPHY_DRAW
    } else {
        TROPHY_NONE
    }
}
```

- `test_triple`은 세 칸이 모두 같고 비어있지 않은지 확인하는 함수입니다.
- 가로 3줄, 세로 3줄, 대각선 2줄 → 총 8가지 승리 패턴 검사입니다.
- 하나라도 참이면 게임은 `TROPHY_WIN`으로 처리합니다.

### 무승부 판정

```rust
else if (game.turn == 9) {
    TROPHY_DRAW
}
```

- 턴 수(`game.turn`)가 9라는 건 이미 9번 수가 진행되었다는 뜻으로 모든 칸(9칸)이 다 채워졌습니다.

### 아직 진행 중

```rust
else {
    TROPHY_NONE
}
```

- 승리도 없고, 보드도 다 안 찼으면 게임은 아직 진행 중입니다.

### 4단계 배포

배포는 `Move.toml`이 있는 폴더에서 실해되어야 합니다.

```bash
sui client publish
```

자세한 배포 내용은 `4. Distributed Counter`의 4단계를 확인해 주세요.

### 5 단계 상호작용

zsh 기준입니다.

### 새로운 계정 2개 생성

```bash
sui client new-address ed25519
```

새로운 계정 2개를 생성하고 각각 faucet에서 가스비를 충전합니다.

Sui Client에서는 `active-address`를 기준으로 트랜잭션이 생성됩니다. 이번 예제에서는 Game Object 소유자, x 플레이어, o 플레이어 이렇게 세 개의 계정이 필요합니다. 각 단계마다 어떤 계정이 트랜잭션을 생성하는지 정확히 확인한 후, 해당 계정으로 전환해야 합니다. 전환은 아래 명령어로 수행합니다.

```bash
sui client switch --address <ACCOUNT_ADDRESS>
```

현재 Sui Client에 존재하는 계정들은 아래 명령어로 확인할 수 있습니다.

```bash
sui client addresses
```

### 5-2 Game object 생성

> transactin 생성자: Game object 생성자 (ADMIN_ADDRESS)

아래 명령어는 Programmable Transaction Block (PTB)를 작성하여 실행하는 예시입니다.

PTB는 Sui에서 제공하는 트랜잭션 빌딩 블록입니다.
기존의 단순한 트랜잭션(예: 단일 Move 함수 호출, 단순 전송)과 달리, 여러 개의 명령을 하나의 트랜잭션 안에서 순차적으로 실행할 수 있습니다.

Sui에서는 트랜잭션이 끝날 때 모든 owned 객체의 소유자가 확정되어 있어야 합니다. `new` 함수는 Game object를 반환만 하고 내부에서 소유권을 넘기지 않으므로, 단순 호출로 반환값을 버리면 소유자 미지정으로 트랜잭션이 실패합니다. 따라서 반환된 객체를 곧바로 적절한 계정에 소유권을 넘기기 위해, 여러 동작을 연속적으로 처리할 수 있는 PTB가 필요합니다.

```bash
sui client ptb \
  --make-move-vec "<u8>" "[]" \
  --assign admin_vec \
  --move-call <PACKAGE_ID>::owned::new \
    @<x_PLAYER_ADDRESS> \
    @<o_PLAYER_ADDRESS> \
    admin_vec \
  --assign game \
  --transfer-objects "[game]" @<ADMIN_ADDRESS> \
  --gas-budget 100000000
```

- `--make-move-vec "<u8>" "[]"`

  - 빈 vector\<u8> 타입을 생성합니다.
  - 생성된 벡터는 이후에 `admin_vec`이라는 이름으로 할당됩니다.
  - 이번 예제에서는 admin 값이 직접적으로 사용되지 않으므로, 빈 값으로 설정합니다.

- `--assign admin_vec`

  - 직전에 생성한 객체를 변수 이름 admin_vec에 저장합니다.
  - `--assign`은 기본적으로 두 개의 파라미터를 요구합니다. 다만, 이전 명령어가 결과를 반환하는 경우 그 결과를 변수에 바인딩해 두었다가 이후 명령어에서 참조할 수 있습니다.
  - `--make-move-vec`는 값을 반환하기 때문에, 그 결과를 바로 `admin_vec`으로 바인딩합니다.

- `--move-call`

  - 특정 Move 모듈(`owned::new`)의 함수를 호출합니다.
  - 즉, `owned::new(x, o, admin)`를 실행해서 Game 객체를 생성합니다.
  - PTB에서 주소나 오브젝트 ID를 전달할 때는 앞에 @를 붙여야 합니다. 이는 16진수 값과 주소를 구분하기 위해 필요합니다.

- `--assign game`

  - 위 `move-call` 결과로 생성된 Game 객체를 변수 `game`에 저장합니다.
  - `new`함수는 Game object를 반환합니다.

- `--transfer-objects`
  - 배열 형식을 인자로 받습니다.
  - `game` 객체를 특정 계정(<ADMIN_ADDRESS>)에게 소유권을 이전합니다.

### 5-3 send_mark 함수 호출

> transactin 생성자: <x_PLAYER_ADDRESS>

Tic_Tac-Toe의 보드에 마크를 할려면 먼저 플레이어는 Mark object를 생성해서 Game object로 보내야 합니다.

```bash
sui client call \
 --package <PACKAGE_ID> \
 --module owned \
 --function send_mark \
 --args <TURNCAP_OBJECT_ID> <ROW> <COL>
```

- `sui client call`

  - Sui 네트워크에 배포된 Move 모듈의 함수를 호출하는 명령입니다.

- <TURNCAP_OBJECT_ID>
  - x_PLAYER의 TURNCAP_OBJECT_ID입니다. (`new` 함수에서 생성되었습니다.)
  - OBJECT_ID 확인하는 법
    1. 이전 `new` 함수의 transaction 결과에서 확인할 수 있습니다. 터미널 출력의 `Object Changes` 항목 중 `Created Objects`에서 확인할 수 있습니다.
    2. `sui client objects` 명령어로 확인할 수 있습니다. 해당 명령어로 `active-address`가 소유하고 있는 object를 찾아볼 수 있습니다.
    3. Sui Scan (https://suiscan.xyz/testnet/home)에서 소유자의 주소를 검색하면, 해당 주소가 보유한 객체들을 확인할 수 있습니다.

### 5-4 place_mark 함수 호출

> transactin 생성자: <ADMIN_ADDRESS>

Game 객체를 소유한 admin은 Game 객체가 소유한 Mark 객체를 사용해 보드에 표시를 하고 게임을 이어갑니다.

```bash
sui client call \
 --package <PACKAGE_ID> \
 --module owned \
 --function place_mark \
 --args <GAME_OBJECT_ID> <MARK_OBJECT_ID>
```

- <MARK_OBJECT_ID>
  - 이전 `send_mark`에서 생성한 MARK object로 Game object가 소유하고 있습니다.
  - 확인하는 법
    1. 이전 `send_mark` 함수 실행 결과는 터미널의 `Transaction Block Events` 항목에서 확인할 수 있습니다. 발생한 `Event`는 체인에 별도로 저장되므로 쉽게 확인할 수 있습니다.
    2. Sui Scan에서 Game 객체의 ID를 검색하면, 해당 객체가 소유한 다른 객체들을 확인할 수 있습니다. 이때는 Object 결과가 아니라 Address 결과를 확인해야 합니다.

### 5-5 y_Player에 대해서도 같은 과정 반복

> transactin 생성자: <y_PLAYER_ADDRESS>

```bash
sui client call \
 --package <PACKAGE_ID> \
 --module owned \
 --function send_mark \
 --args <TURNCAP_OBJECT_ID> <ROW> <COL>
```

> transactin 생성자: <ADMIN_ADDRESS>

```bash
sui client call \
 --package <PACKAGE_ID> \
 --module owned \
 --function place_mark \
 --args <GAME_OBJECT_ID> <MARK_OBJECT_ID>
```

### 6단계 게임 진행

x_PLAYER와 y_PLAYER가 번갈아가며 게임을 진행합니다. 한 줄이 완성되거나 9번의 턴이 모두 끝나면 게임이 종료됩니다.
